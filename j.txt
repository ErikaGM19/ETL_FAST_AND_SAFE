import os
import sys
import asyncio
import warnings
import yaml
from subprocess import run
from sqlalchemy import create_engine
import platform
import psycopg2
import pandas as pd

# Establecer la política de bucle de eventos para Windows
if platform.system() == "Windows":
    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

warnings.filterwarnings("ignore", category=RuntimeWarning)

# Leer configuración de la conexión desde el archivo YAML
with open('./configBD/config.yml', 'r', encoding='utf-8') as f:
    config = yaml.safe_load(f)
    config_etl = config['bodega']

def get_db_connection(require_ssl=False):
    """
    Función mejorada para manejar conexiones con opción SSL flexible
    """
    ssl_mode = 'require' if require_ssl else 'prefer'
    try:
        conn = psycopg2.connect(
            dbname=config_etl['db'],
            user=config_etl['user'],
            password=config_etl['password'],
            host=config_etl['host'],
            port=config_etl['port'],
            sslmode=ssl_mode
        )
        return conn
    except psycopg2.OperationalError as e:
        if "SSL" in str(e):
            print("Advertencia: Fallo en conexión SSL, intentando sin SSL...")
            return psycopg2.connect(
                dbname=config_etl['db'],
                user=config_etl['user'],
                password=config_etl['password'],
                host=config_etl['host'],
                port=config_etl['port'],
                sslmode='disable'
            )
        raise

def get_sqlalchemy_engine(require_ssl=False):
    """
    Función para crear engine de SQLAlchemy con opción SSL flexible
    """
    ssl_param = 'require' if require_ssl else 'prefer'
    url_etl = (
        f"{config_etl['driver']}://{config_etl['user']}:{config_etl['password']}@"
        f"{config_etl['host']}:{config_etl['port']}/{config_etl['db']}?sslmode={ssl_param}"
    )
    return create_engine(url_etl)

def run_notebook(notebook_path):
    """
    Ejecuta un notebook de Jupyter usando el mismo intérprete (sys.executable).
    """
    print(f"Running notebook: {notebook_path}")
    run(
        [
            sys.executable,
            "-m", "nbconvert",
            "--to", "notebook",
            "--execute",
            "--inplace",
            "--clear-output",
            notebook_path
        ],
        check=True
    )

def check_data_changes():
    """
    Verifica si hay cambios en los datos (dimensiones y hechos).
    Retorna True si debe ejecutar nuevamente los notebooks; False en caso contrario.
    """
    # Implementa aquí la lógica real que compare timestamps, hashes, etc.
    return True  # Por defecto siempre ejecuta

def check_if_db_deleted():
    """
    Verifica si la base de datos (dimensiones y hechos) ha sido eliminada.
    Retorna True si la BD fue borrada y hay que recrear desde cero; False en caso contrario.
    """
    # Implementa la lógica adecuada para tu caso.
    return False

def clean_etl_tables():
    """
    Se conecta a la base ETL y ejecuta las sentencias de borrado definidas en 'sqlscripts2.yml'.
    Usa la nueva función de conexión flexible.
    """
    conn = None
    cur = None
    try:
        conn = get_db_connection(require_ssl=False)
        cur = conn.cursor()
        with open('sqlscripts2.yml', 'r', encoding='utf-8') as f:
            sql_scripts = yaml.safe_load(f)
            drop_tables_query = sql_scripts.get('drop_tables', '')
            if drop_tables_query:
                cur.execute(drop_tables_query)
        conn.commit()
    except Exception as e:
        print(f"Error al limpiar las tablas: {e}")
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

def execute_sql_scripts():
    """
    Función mejorada para ejecutar los scripts SQL finales con manejo de errores
    """
    conn = None
    cur = None
    try:
        conn = get_db_connection(require_ssl=False)
        cur = conn.cursor()
        with open('sqlscripts.yml', 'r', encoding='utf-8') as f:
            sql = yaml.safe_load(f)
            for key, val in sql.items():
                try:
                    print(f"Ejecutando: {key}")
                    cur.execute(val)
                    conn.commit()
                except Exception as e:
                    print(f"Error al ejecutar {key}: {e}")
                    conn.rollback()
    except Exception as e:
        print(f"Error de conexión al ejecutar scripts SQL: {e}")
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

def main():
    # Inicializar motor de SQLAlchemy (para notebooks que lo necesiten)
    etl_engine = get_sqlalchemy_engine(require_ssl=False)
    
    print("Iniciando proceso ETL...")
    clean_etl_tables()

    # Rutas a los notebooks que se deben ejecutar
    notebooks = [
        os.path.join("mensajeria", "dimensiones", "dm_cliente.ipynb"),
        os.path.join("mensajeria", "dimensiones", "dm_sede.ipynb"),
        os.path.join("mensajeria", "dimensiones", "dm_tiempo.ipynb"),
        os.path.join("mensajeria", "dimensiones", "dm_mensajero.ipynb"),
        os.path.join("mensajeria", "hechos", "hecho_novedades.ipynb"),
        os.path.join("mensajeria", "hechos", "hecho_servicios.ipynb"),
    ]

    data_changed = check_data_changes()
    db_deleted = check_if_db_deleted()

    if not data_changed and not db_deleted:
        print("Las dimensiones y hechos ya están creados y sin cambios.")
        return

    # Ejecutar cada notebook
    for notebook in notebooks:
        if os.path.exists(notebook):
            print(f"\nProcesando notebook: {notebook}")
            try:
                run_notebook(notebook)
                print(f"Notebook {notebook} completado con éxito")
            except Exception as e:
                print(f"Error al ejecutar el notebook {notebook}: {e}")
                # Continuar con el siguiente notebook en lugar de fallar
        else:
            print(f"\nAdvertencia: Notebook {notebook} no encontrado")

    # Ejecutar scripts SQL finales
    print("\nEjecutando scripts SQL finales...")
    execute_sql_scripts()
    print("Proceso ETL completado")

if __name__ == "__main__":
    main()
# Versión mejorada del archivo s.yml con manejo robusto de duplicados

setup_cleanup: |
  -- 1. Limpieza inicial - Eliminar constraints existentes
  ALTER TABLE fact_servicios DROP CONSTRAINT IF EXISTS pk_fact_servicios;
  ALTER TABLE fact_servicios DROP CONSTRAINT IF EXISTS fk_fact_servicios_tiempo;
  ALTER TABLE fact_servicios DROP CONSTRAINT IF EXISTS fk_fact_servicios_cliente;
  ALTER TABLE fact_servicios DROP CONSTRAINT IF EXISTS fk_fact_servicios_sede_origen;
  ALTER TABLE fact_servicios DROP CONSTRAINT IF EXISTS fk_fact_servicios_sede_destino;
  ALTER TABLE fact_servicios DROP CONSTRAINT IF EXISTS fk_fact_servicios_mensajero;

  ALTER TABLE fact_novedades DROP CONSTRAINT IF EXISTS pk_fact_novedades;
  ALTER TABLE fact_novedades DROP CONSTRAINT IF EXISTS fk_fn_tiempo;
  ALTER TABLE fact_novedades DROP CONSTRAINT IF EXISTS fk_fn_mensajero;
  ALTER TABLE fact_novedades DROP CONSTRAINT IF EXISTS fk_fn_cliente;
  ALTER TABLE fact_novedades DROP CONSTRAINT IF EXISTS fk_fn_sede;

  -- 2. Corregir tipos de datos manteniendo la compatibilidad
  ALTER TABLE fact_servicios ALTER COLUMN "TiempoKey" TYPE BIGINT USING "TiempoKey"::BIGINT;
  ALTER TABLE fact_servicios ALTER COLUMN "SedeOrigenKey" TYPE BIGINT USING "SedeOrigenKey"::BIGINT;
  ALTER TABLE fact_servicios ALTER COLUMN "SedeDestinoKey" TYPE BIGINT USING "SedeDestinoKey"::BIGINT;
  ALTER TABLE fact_servicios ALTER COLUMN "MensajeroKey" TYPE BIGINT USING "MensajeroKey"::BIGINT;

  ALTER TABLE fact_novedades ALTER COLUMN "TiempoKey" TYPE BIGINT USING "TiempoKey"::BIGINT;
  ALTER TABLE fact_novedades ALTER COLUMN "SedeKey" TYPE BIGINT USING "SedeKey"::BIGINT;

dimensions_pk: |
  -- 3. PKs en dimensiones (sin cambios)
  ALTER TABLE dim_cliente ADD CONSTRAINT pk_cliente PRIMARY KEY ("ClienteKey");
  ALTER TABLE dim_mensajero ADD CONSTRAINT pk_mensajero PRIMARY KEY ("MensajeroKey");
  ALTER TABLE dim_sede ADD CONSTRAINT pk_sede PRIMARY KEY ("SedeKey");
  ALTER TABLE dim_tiempo ADD CONSTRAINT pk_tiempo PRIMARY KEY ("tiempo_key");

facts_pk: |
  -- 4. Nueva estrategia para PKs en hechos con manejo de duplicados
  
  -- Primero añadir columna de identificación única si no existe
  DO $$
  BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                  WHERE table_name = 'fact_servicios' AND column_name = 'servicio_id') THEN
      ALTER TABLE fact_servicios ADD COLUMN servicio_id SERIAL;
      UPDATE fact_servicios SET servicio_id = nextval(pg_get_serial_sequence('fact_servicios', 'servicio_id'));
    END IF;
  END $$;

  -- Crear PK usando el ID único artificial
  ALTER TABLE fact_servicios
    ADD CONSTRAINT pk_fact_servicios PRIMARY KEY (servicio_id);
  COMMENT ON CONSTRAINT pk_fact_servicios ON fact_servicios IS 'Llave primaria artificial para servicios (permite duplicados en campos naturales)';

  -- Crear índice único alternativo para control de duplicados
  CREATE UNIQUE INDEX IF NOT EXISTS idx_servicio_unico 
    ON fact_servicios ("ServicioKey", "TiempoKey", "ClienteKey", "SedeOrigenKey", "SedeDestinoKey");
  COMMENT ON INDEX idx_servicio_unico IS 'Índice para controlar registros realmente duplicados';

  -- Para fact_novedades (similar)
  DO $$
  BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                  WHERE table_name = 'fact_novedades' AND column_name = 'NovedadKey') THEN
      ALTER TABLE fact_novedades ADD COLUMN "NovedadKey" SERIAL;
    END IF;
  END $$;

  ALTER TABLE fact_novedades
    ADD CONSTRAINT pk_fact_novedades PRIMARY KEY ("NovedadKey");

facts_fk_servicios: |
  -- 5. FKs (sin cambios)
  ALTER TABLE fact_servicios
    ADD CONSTRAINT fk_fact_servicios_tiempo FOREIGN KEY ("TiempoKey")
    REFERENCES dim_tiempo("tiempo_key");

  ALTER TABLE fact_servicios
    ADD CONSTRAINT fk_fact_servicios_cliente FOREIGN KEY ("ClienteKey")
    REFERENCES dim_cliente("ClienteKey");

  ALTER TABLE fact_servicios
    ADD CONSTRAINT fk_fact_servicios_sede_origen FOREIGN KEY ("SedeOrigenKey")
    REFERENCES dim_sede("SedeKey");

  ALTER TABLE fact_servicios
    ADD CONSTRAINT fk_fact_servicios_sede_destino FOREIGN KEY ("SedeDestinoKey")
    REFERENCES dim_sede("SedeKey");

  ALTER TABLE fact_servicios
    ADD CONSTRAINT fk_fact_servicios_mensajero FOREIGN KEY ("MensajeroKey")
    REFERENCES dim_mensajero("MensajeroKey");

facts_fk_novedades: |
  -- 6. FKs para novedades (sin cambios)
  ALTER TABLE fact_novedades
    ADD CONSTRAINT fk_fn_tiempo FOREIGN KEY ("TiempoKey")
    REFERENCES dim_tiempo("tiempo_key");

  ALTER TABLE fact_novedades
    ADD CONSTRAINT fk_fn_mensajero FOREIGN KEY ("MensajeroKey")
    REFERENCES dim_mensajero("MensajeroKey");

  ALTER TABLE fact_novedades
    ADD CONSTRAINT fk_fn_cliente FOREIGN KEY ("ClienteKey")
    REFERENCES dim_cliente("ClienteKey");

  ALTER TABLE fact_novedades
    ADD CONSTRAINT fk_fn_sede FOREIGN KEY ("SedeKey")
    REFERENCES dim_sede("SedeKey");

etl_strategy: |
  -- 7. Estrategia ETL mejorada para manejo de duplicados
  
  -- Tabla de staging con columna adicional para control de cambios
  CREATE TABLE IF NOT EXISTS stg_servicios (
    LIKE fact_servicios INCLUDING DEFAULTS,
    accion VARCHAR(10) -- 'INSERT' o 'UPDATE'
  );

  -- Función para carga incremental con detección de duplicados
  CREATE OR REPLACE FUNCTION carga_servicios() RETURNS void AS $$
  BEGIN
    -- Insertar nuevos registros (sin duplicados exactos)
    INSERT INTO fact_servicios
    SELECT s.* FROM stg_servicios s
    WHERE s.accion = 'INSERT'
    ON CONFLICT ON CONSTRAINT pk_fact_servicios DO NOTHING;
    
    -- Actualizar existentes si es necesario
    UPDATE fact_servicios f
    SET 
      "ClienteKey" = s."ClienteKey",
      "MensajeroKey" = s."MensajeroKey",
      "SedeOrigenKey" = s."SedeOrigenKey",
      "SedeDestinoKey" = s."SedeDestinoKey",
      -- otros campos...
      "EstadoServicio" = s."EstadoServicio"
    FROM stg_servicios s
    WHERE f."ServicioKey" = s."ServicioKey" 
      AND f."TiempoKey" = s."TiempoKey"
      AND s.accion = 'UPDATE';
    
    TRUNCATE stg_servicios;
  END;
  $$ LANGUAGE plpgsql;

  -- Función para identificar y limpiar duplicados problemáticos
  CREATE OR REPLACE FUNCTION limpiar_duplicados_servicios() RETURNS void AS $$
  BEGIN
    -- Eliminar duplicados exactos manteniendo el primero
    DELETE FROM fact_servicios
    WHERE servicio_id IN (
      SELECT fs2.servicio_id
      FROM fact_servicios fs1
      JOIN fact_servicios fs2 ON 
        fs1."ServicioKey" = fs2."ServicioKey" AND
        fs1."TiempoKey" = fs2."TiempoKey" AND
        fs1.servicio_id < fs2.servicio_id
    );
  END;
  $$ LANGUAGE plpgsql;